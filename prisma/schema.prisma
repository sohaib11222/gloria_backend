generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum CompanyType {
  AGENT
  SOURCE
}

enum CompanyStatus {
  PENDING_VERIFICATION
  ACTIVE
  SUSPENDED
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum EchoJobStatus {
  IN_PROGRESS
  COMPLETE
}

enum Role {
  ADMIN
  AGENT_USER
  SOURCE_USER
}

enum AgreementStatus {
  DRAFT
  OFFERED
  ACCEPTED
  ACTIVE
  SUSPENDED
  EXPIRED
}

enum BookingStatus {
  REQUESTED
  CONFIRMED
  CANCELLED
  FAILED
}

model Company {
  id           String        @id @default(cuid())
  companyName  String
  type         CompanyType
  email        String        @unique
  passwordHash String
  status       CompanyStatus @default(PENDING_VERIFICATION)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  // Email verification fields
  emailVerified   Boolean   @default(false)
  emailOtp        String?
  emailOtpExpires DateTime?

  // Company code (CMP00023 format) - required for Sources
  companyCode String? @unique

  // Approval status for admin review
  approvalStatus ApprovalStatus @default(PENDING)

  // Whitelist configuration
  whitelistedDomains String? @db.Text // Comma-separated domains/IPs

  // Adapter configuration for Sources
  adapterType  String? // "mock" | "grpc" (or future "http") - must be explicitly set, no default
  grpcEndpoint String?
  httpEndpoint String? // Optional HTTP endpoint for JSON fallback/test

  // TLS/mTLS configuration for gRPC (JSON)
  tlsProfile Json?

  // Vendor metadata (JSON)
  vendorMetadata Json?

  // gRPC test result tracking
  lastGrpcTestResult Json? // Stores the full test result
  lastGrpcTestAt     DateTime? // When the test was performed

  // Location sync tracking
  lastLocationSyncAt DateTime? // When locations were last synced

  users            User[]
  agentAgreements  Agreement[]       @relation("AgentAgreements")
  sourceAgreements Agreement[]       @relation("SourceAgreements")
  sourceLocations  SourceLocation[]
  branches         Branch[]
  echoJobs         EchoJob[]
  locationRequests LocationRequest[]
  createdTickets   SupportTicket[]   @relation("CreatedTickets")
}

model User {
  id           String   @id @default(cuid())
  companyId    String
  email        String   @unique
  passwordHash String
  role         Role
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

model Agreement {
  id           String          @id @default(cuid())
  agentId      String
  sourceId     String
  agreementRef String
  status       AgreementStatus @default(DRAFT)
  validFrom    DateTime?
  validTo      DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  agent             Company                     @relation("AgentAgreements", fields: [agentId], references: [id], onDelete: Cascade)
  source            Company                     @relation("SourceAgreements", fields: [sourceId], references: [id], onDelete: Cascade)
  locationOverrides AgreementLocationOverride[]

  @@unique([sourceId, agreementRef])
  @@index([agentId, status, createdAt])
  @@index([sourceId, status, createdAt])
}

model UNLocode {
  unlocode  String  @id
  country   String
  place     String
  iataCode  String?
  latitude  Float?
  longitude Float?

  sourceLocations            SourceLocation[]
  agreementLocationOverrides AgreementLocationOverride[]

  @@index([country])
  @@index([place])
}

model SourceLocation {
  id       String @id @default(cuid())
  sourceId String
  unlocode String
  isMock   Boolean @default(false) // Indicates if location was synced from a mock adapter (test data)

  source Company  @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  loc    UNLocode @relation(fields: [unlocode], references: [unlocode], onDelete: Cascade)

  @@unique([sourceId, unlocode])
  @@index([sourceId])
}

model AgreementLocationOverride {
  id          String  @id @default(cuid())
  agreementId String
  unlocode    String
  allowed     Boolean @default(true)

  agreement Agreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
  loc       UNLocode  @relation(fields: [unlocode], references: [unlocode], onDelete: Cascade)

  @@unique([agreementId, unlocode])
}

model AvailabilityJob {
  id              String   @id @default(cuid())
  agentId         String
  criteriaJson    Json
  status          String   @default("RUNNING")
  expectedSources Int      @default(0)
  createdAt       DateTime @default(now())

  results AvailabilityResult[]

  @@index([agentId])
  @@index([createdAt])
}

model AvailabilityResult {
  id        String   @id @default(cuid())
  jobId     String
  seq       Int
  sourceId  String
  offerJson Json
  createdAt DateTime @default(now())

  job AvailabilityJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@unique([jobId, seq])
  @@index([jobId, seq])
}

model Booking {
  id                     String        @id @default(cuid())
  agentId                String
  sourceId               String
  agreementRef           String
  supplierBookingRef     String?
  agentBookingRef        String?
  idempotencyKey         String?
  status                 BookingStatus @default(REQUESTED)
  payloadJson            Json?
  
  // Availability context (links booking to original search)
  availabilityRequestId  String?       // Links to AvailabilityJob.requestId
  
  // Location details (from availability search)
  pickupUnlocode         String?
  dropoffUnlocode        String?
  pickupDateTime         DateTime?
  dropoffDateTime        DateTime?
  
  // Vehicle and driver details (from availability search/offer)
  vehicleClass           String?
  vehicleMakeModel       String?
  ratePlanCode           String?
  driverAge              Int?
  residencyCountry       String?       // ISO 3166-1 alpha-2
  
  // Customer and payment information (JSON fields for flexibility)
  customerInfoJson       Json?         // Customer name, contact details, etc.
  paymentInfoJson        Json?         // Payment details, card info, etc.
  
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @updatedAt

  @@unique([agentId, idempotencyKey])
  @@index([agentId, agreementRef, createdAt])
  @@index([sourceId, supplierBookingRef])
  @@index([availabilityRequestId])
}

model BookingHistory {
  id            String   @id @default(cuid())
  bookingId     String
  eventType     String   // CREATED, MODIFIED, CANCELLED, STATUS_CHANGED
  changes       Json?    // Field-level changes: { field: { before, after } }
  beforeState   Json?    // Snapshot of booking before change
  afterState    Json?    // Snapshot of booking after change
  userId        String?  // User/company ID who made the change
  source        String?  // Source of change: AGENT, SOURCE, SYSTEM, ADMIN
  metadata      Json?    // Additional metadata (reason, notes, etc.)
  timestamp     DateTime @default(now())

  @@index([bookingId, timestamp])
  @@index([bookingId, eventType])
  @@index([timestamp])
}

model Notification {
  id        String    @id @default(cuid())
  companyId String?
  userId    String?
  type      String
  title     String
  message   String
  readAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([companyId, createdAt])
}

model AuditLog {
  id             String   @id @default(cuid())
  direction      String // IN|OUT
  endpoint       String?
  requestId      String?
  companyId      String?
  sourceId       String?
  agreementRef   String? // [AUTO-AUDIT] Added to log explicit agreement reference
  httpStatus     Int?
  grpcStatus     Int?
  maskedRequest  String?  @db.Text
  maskedResponse String?  @db.Text
  durationMs     Int?
  createdAt      DateTime @default(now())

  @@index([createdAt])
  @@index([companyId, createdAt])
  @@index([sourceId, createdAt])
  @@index([endpoint, createdAt])
  @@index([requestId])
  @@index([agreementRef, createdAt])
}

model VerificationReport {
  id         String   @id @default(cuid())
  companyId  String
  kind       String // AGENT|SOURCE
  passed     Boolean
  reportJson Json
  createdAt  DateTime @default(now())
}

// [AUTO-AUDIT] API key storage for SDK and service authentication
model ApiKey {
  id          String   @id @default(cuid())
  name        String
  ownerType   String // agent|source|admin
  ownerId     String
  keyHash     String // hashed key (bcrypt/sha512)
  permissions Json // array of strings
  status      String // active|revoked
  createdAt   DateTime @default(now())

  @@index([ownerType, ownerId])
  @@index([status, createdAt])
}

// [AUTO-AUDIT] IP whitelist for ingress control
model WhitelistedIp {
  id        String   @id @default(cuid())
  ip        String
  type      String // agent|source|admin
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())

  @@unique([ip, type])
  @@index([enabled])
}

//

model IdempotencyKey {
  id           String   @id @default(cuid())
  agentId      String
  scope        String
  key          String
  responseHash String?
  createdAt    DateTime @default(now())

  @@unique([agentId, scope, key], map: "agent_scope_key_unique")
}

model SourceHealth {
  id            String    @id @default(cuid())
  sourceId      String    @unique
  slowCount     Int       @default(0)
  sampleCount   Int       @default(0)
  slowRate      Float     @default(0.0)
  backoffLevel  Int       @default(0)
  excludedUntil DateTime?
  lastResetBy   String? // Admin user ID who reset
  lastResetAt   DateTime?
  strikeCount   Int       @default(0) // NEW: Track strikes (3 strikes trigger backoff)
  lastStrikeAt  DateTime? // NEW: When last strike occurred
  updatedAt     DateTime  @updatedAt

  @@index([sourceId])
  @@index([excludedUntil])
}

// Branch/Location model for supplier branches
model Branch {
  id             String   @id @default(cuid())
  sourceId       String
  agreementId    String? // Optional: if availability differs by agreement
  branchCode     String
  name           String
  status         String?
  locationType   String?
  collectionType String?
  email          String?
  phone          String?
  latitude       Float?
  longitude      Float?
  addressLine    String?  @db.Text
  city           String?
  postalCode     String?
  country        String?
  countryCode    String?
  natoLocode     String? // Maps to NATO LOCODES
  rawJson        Json? // Full branch sub-JSON from supplier
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  source Company @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@unique([sourceId, branchCode])
  @@index([sourceId])
  @@index([agreementId])
  @@index([natoLocode])
}

// Echo PoC models for Submit+Poll pattern
model EchoJob {
  id                String        @id @default(cuid())
  requestId         String        @unique // UUIDv4
  agentId           String
  agreementId       String?
  status            EchoJobStatus @default(IN_PROGRESS)
  startedAt         DateTime      @default(now())
  expiresAt         DateTime
  totalExpected     Int           @default(0)
  responsesReceived Int           @default(0)
  timedOutSources   Int           @default(0)
  lastSeq           BigInt        @default(0)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  agent Company    @relation(fields: [agentId], references: [id], onDelete: Cascade)
  items EchoItem[]

  @@index([agentId, status, createdAt])
  @@index([requestId])
  @@index([expiresAt])
}

model EchoItem {
  id            String   @id @default(cuid())
  requestId     String
  seq           BigInt
  echoedMessage String   @db.Text
  echoedAttrs   Json? // map<string,string>
  createdAt     DateTime @default(now())

  job EchoJob @relation(fields: [requestId], references: [requestId], onDelete: Cascade)

  @@unique([requestId, seq])
  @@index([requestId, seq])
}

// Location Request model for sources to request new locations
model LocationRequest {
  id           String    @id @default(cuid())
  sourceId     String
  source       Company   @relation(fields: [sourceId], references: [id], onDelete: Cascade)
  locationName String
  country      String
  city         String?
  address      String?   @db.Text
  iataCode     String?
  reason       String?   @db.Text
  status       String    @default("PENDING") // PENDING, APPROVED, REJECTED
  adminNotes   String?   @db.Text
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  reviewedBy   String? // User ID of admin who reviewed
  reviewedAt   DateTime?

  @@index([sourceId])
  @@index([status])
  @@index([createdAt])
}

model SmtpConfig {
  id        String   @id @default(cuid())
  host      String
  port      Int      @default(587)
  secure    Boolean  @default(false) // true for TLS/SSL (port 465), false for STARTTLS (port 587)
  user      String
  password  String   // Encrypted or plain (admin's choice)
  fromEmail String   @default("no-reply@carhire.local")
  fromName  String?  @default("Car Hire Middleware")
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  updatedBy String? // User ID of admin who last updated

  @@unique([id])
}

enum SupportTicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum MessageSenderType {
  ADMIN
  AGENT
  SOURCE
}

model SupportTicket {
  id          String              @id @default(cuid())
  title       String
  status      SupportTicketStatus @default(OPEN)
  createdById String              // Company ID of creator (Agent or Source)
  createdBy   Company             @relation("CreatedTickets", fields: [createdById], references: [id], onDelete: Cascade)
  assignedTo  String?             // Admin user ID (optional)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  messages    SupportMessage[]

  @@index([createdById, createdAt])
  @@index([status, createdAt])
  @@index([assignedTo])
}

model SupportMessage {
  id          String            @id @default(cuid())
  ticketId    String
  ticket      SupportTicket     @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  senderId    String            // Company ID or Admin user ID
  senderType  MessageSenderType
  content     String?           @db.Text
  imageUrl    String?           @db.Text // Base64 encoded image data URL
  readAt      DateTime?
  createdAt   DateTime          @default(now())

  @@index([ticketId, createdAt])
  @@index([senderId, createdAt])
}